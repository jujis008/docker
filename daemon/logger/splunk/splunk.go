// +build linux

package splunk

import (
	"bytes"
	"crypto/tls"
	"crypto/x509"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"

	"github.com/Sirupsen/logrus"
	"github.com/docker/docker/daemon/logger"
	"github.com/docker/docker/pkg/urlutil"
)

const (
	Name                     = "splunk"
	SplunkUrl                = "splunk-url"
	SplunkToken              = "splunk-token"
	SplunkSource             = "splunk-source"
	SplunkSourceType         = "splunk-sourcetype"
	SplunkIndex              = "splunk-index"
	SplunkCAPath             = "splunk-capath"
	SplunkCAName             = "splunk-caname"
	SplunkInsecureSkipVerify = "splunk-insecureskipverify"
)

type SplunkLogger struct {
	client    *http.Client
	transport *http.Transport

	url         string
	auth        string
	nullMessage *SplunkMessage
}

type SplunkMessage struct {
	Event      SplunkMessageEvent `json:"event"`
	Time       string             `json:"time"`
	Host       string             `json:"host"`
	Source     string             `json:"source,omitempty"`
	SourceType string             `json:"sourcetype,omitempty"`
	Index      string             `json:"index,omitempty"`
}

type SplunkMessageEvent struct {
	Line        string `json:"line"`
	ContainerID string `json:"containerId"`
	Source      string `json:"source"`
}

func init() {
	if err := logger.RegisterLogDriver(Name, New); err != nil {
		logrus.Fatal(err)
	}
	if err := logger.RegisterLogOptValidator(Name, ValidateLogOpt); err != nil {
		logrus.Fatal(err)
	}
}

func New(ctx logger.Context) (logger.Logger, error) {
	hostname, err := ctx.Hostname()
	if err != nil {
		return nil, fmt.Errorf("%s: cannot access hostname to set source field", Name)
	}

	// Parse and validate Splunk Url
	splunkUrl, err := parseUrl(ctx)
	if err != nil {
		return nil, err
	}

	// Splunk Token is required parameter
	splunkToken, ok := ctx.Config[SplunkToken]
	if !ok {
		return nil, fmt.Errorf("%s: %s is expected", SplunkToken)
	}

	tlsConfig := &tls.Config{}

	// Splunk is using autogenerated certificates by default,
	// allow users to trust them with skiping verification
	if insecureSkipVerifyStr, ok := ctx.Config[SplunkInsecureSkipVerify]; ok {
		insecureSkipVerify, err := strconv.ParseBool(insecureSkipVerifyStr)
		if err != nil {
			return nil, err
		}
		tlsConfig.InsecureSkipVerify = insecureSkipVerify
	}

	// If path to the root certificate is provided - load it
	if caPath, ok := ctx.Config[SplunkCAPath]; ok {
		caCert, err := ioutil.ReadFile(caPath)
		if err != nil {
			return nil, err
		}
		caPool := x509.NewCertPool()
		caPool.AppendCertsFromPEM(caCert)
		tlsConfig.RootCAs = caPool
	}

	if caName, ok := ctx.Config[SplunkCAName]; ok {
		tlsConfig.ServerName = caName
	}

	transport := &http.Transport{
		TLSClientConfig: tlsConfig,
	}
	client := &http.Client{
		Transport: transport,
	}

	var nullMessage = &SplunkMessage{
		Host: hostname,
	}

	// Optional parameters for messages
	nullMessage.Source = ctx.Config[SplunkSource]
	nullMessage.SourceType = ctx.Config[SplunkSourceType]
	nullMessage.Index = ctx.Config[SplunkIndex]

	logger := &SplunkLogger{
		client:      client,
		transport:   transport,
		url:         splunkUrl.String(),
		auth:        "Splunk " + splunkToken,
		nullMessage: nullMessage,
	}

	err = verifySplunkConnection(logger)
	if err != nil {
		return nil, err
	}

	return logger, nil
}

func (l *SplunkLogger) Log(msg *logger.Message) error {
	// Construct message as a copy of nullMessage
	splunkMessage := *l.nullMessage
	splunkMessage.Time = fmt.Sprintf("%f", float64(msg.Timestamp.UnixNano())/1000000000)
	splunkMessage.Event = SplunkMessageEvent{
		Line:        string(msg.Line),
		ContainerID: msg.ContainerID,
		Source:      msg.Source,
	}

	jsonEvent, err := json.Marshal(&splunkMessage)
	if err != nil {
		return err
	}
	req, err := http.NewRequest("POST", l.url, bytes.NewBuffer(jsonEvent))
	if err != nil {
		return err
	}
	req.Header.Set("Authorization", l.auth)
	res, err := l.client.Do(req)
	if err != nil {
		return err
	}
	if res.Body != nil {
		defer res.Body.Close()
	}
	if res.StatusCode != http.StatusOK {
		var body []byte
		body, err = ioutil.ReadAll(res.Body)
		if err != nil {
			return err
		}
		return fmt.Errorf("%s: failed to send event - %s - %s", Name, res.Status, body)
	} else {
		io.Copy(ioutil.Discard, res.Body)
	}
	return nil
}

func (l *SplunkLogger) Close() error {
	l.transport.CloseIdleConnections()
	return nil
}

func (l *SplunkLogger) Name() string {
	return Name
}

func ValidateLogOpt(cfg map[string]string) error {
	for key := range cfg {
		switch key {
		case SplunkUrl:
		case SplunkToken:
		case SplunkSource:
		case SplunkSourceType:
		case SplunkIndex:
		case SplunkCAPath:
		case SplunkCAName:
		case SplunkInsecureSkipVerify:
		default:
			return fmt.Errorf("unknown log opt '%s' for %s log driver", key, Name)
		}
	}
	return nil
}

func parseUrl(ctx logger.Context) (*url.URL, error) {
	splunkUrlStr, ok := ctx.Config[SplunkUrl]
	if !ok {
		return nil, fmt.Errorf("%s: %s is expected", SplunkUrl)
	}

	splunkUrl, err := url.Parse(splunkUrlStr)
	if err != nil {
		return nil, fmt.Errorf("%s: failed to parse %s as url value in %s", Name, splunkUrlStr, SplunkUrl)
	}

	if !urlutil.IsURL(splunkUrlStr) ||
		!splunkUrl.IsAbs() ||
		(splunkUrl.Path != "" && splunkUrl.Path != "/") ||
		splunkUrl.RawQuery != "" ||
		splunkUrl.Fragment != "" {
		return nil, fmt.Errorf("%s: expected format shema://dns_name_or_ip:port for %s", Name, SplunkUrl)
	}

	splunkUrl.Path = "/services/collector/event"

	return splunkUrl, nil
}

func verifySplunkConnection(l *SplunkLogger) error {
	req, err := http.NewRequest("OPTIONS", l.url, nil)
	if err != nil {
		return err
	}
	res, err := l.client.Do(req)
	if err != nil {
		return err
	}
	if res.Body != nil {
		defer res.Body.Close()
	}
	if res.StatusCode != http.StatusOK {
		var body []byte
		body, err = ioutil.ReadAll(res.Body)
		if err != nil {
			return err
		}
		return fmt.Errorf("%s: failed to verify connection - %s - %s", Name, res.Status, body)
	}
	return nil
}
